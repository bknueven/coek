Component Sequences
===================

Component sequences offer an alternative to indexed components where
the elements of the associative array are dynamically generated.
The key idea is to use quantified expressions to express the elements
of an associative array.  This avoids the use of explicit looping,
and it allows for manipulation of the quantified expression (e.g. for
automatic differentiation).

Quantified Expressions
----------------------

Quantified expressions require the specification of bound variables.
COEK allows for a weak specification of bound variables, where the
variable binding is defered until the specification of the \textit{quantified
expression}.  The ``set_element()`` function is used to specify a variable
that will be bound in a quantified expression:

.. code:: C++

    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

.. admonition:: WEH

    This declaration does not require the specification of the associated set.  For example, we could imagine the
    following syntax:

    .. code:: C++

        auto A = coek::RangeSet(1,10);
        auto i = A.element("i");

        auto B = coek::Set(A);
        auto j = B[i].element("j");

    However, it is not obvious that this syntax makes sense.  The bound variable ``j`` is dependent on the set
    ``B[i]``, which is not resolved until later.

    Further, dynamic binding of variables seems possible, which makes this syntax unnecessary.

Quantifiers can be expressed using the COEK ``Forall()`` function, which
generates a sequence of set elements.  The sequence object created by
this function is not directly used by COEK users, but it is passed to
COEK components to initialize them.  For example:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto i = coek::set_element("i");

    auto x = coek::variable("x", coek::Forall(i).In(A) );   // Explicit quantification
    auto y = coek::variable("y", A );                       // Implicit quantification

Here, ``Forall()`` binds the variable ``i``, and the ``In()`` method
specifies the set.  This and later examples illustrate that explicit
and implicit quantification is possible with COEK, resulting in the same
set declaration used to index variables ``x`` and ``y``.

More generally, multiple variables can be bound in a call to ``Forall()``:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

    auto x = coek::variable("x", coek::Forall(i,j).In(A*A) );
    auto y = coek::variable("y", A*A );                      

Function chaining can also be used to nest quantification across different
sets, including indexed sets:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto B = coek::RangeSet(1,100);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

    auto x = coek::variable("x", coek::Forall(i).In(A).Forall(j).In(B) );
    auto y = coek::variable("y", A*B );                                 

In all of the previous examples, the set declarations for ``x`` and ``y`` are the same.  However, the real
utility of explicit quantification in COEK is that the bound variables can be used in quantified expressions
and to initialize component values.  For example, indexed sets can be used in quantified 
expressions and indexed by set elements:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto C = coek::Set(A);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

    auto y = coek::variable("y", coek::Forall(i).In(A).Forall(j).In(C[i]) );

Here, the set ``C[i]`` is not resolved immediately, but rather when the
quantified expression is expanded.  Similarly, the ``ST()`` method can be
used to declare constraints on the bound variables that limit the range
of set elements generated by the quantified expression.  For example:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

    auto x = coek::variable("x", coek::Forall(i,j).In(A*A).ST( i < j ) );

The following sections illustrate how explicit quantification can be
used to index COEK components and initialize their values.


Expressions
-----------

Aside from component declarations, quantified expressions can be used to provide a compact way to define complex expressions.
The ``Sum()`` function supports the declaration of a sum with a COEK expression that includes set elements, and a quantified expression that binds those set elements.  For example:

.. code:: C++

    auto A = coek::RangeSet(1,10);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");
    
    auto x = coek::variable("x", A);
    auto xsum = coek::Sum( x(i), coek::Forall(i).In(A) );

    auto y = coek::variable("y", A*A);
    auto ysum = coek::Sum( j*coek::Sum(y(i,j), coek::Forall(j).In(A)), coek::Forall(i).In(A) );

.. note::

    The following syntax can also be used for a simple sum of an indexed variable:

    .. code:: C++

        auto xsum = coek::Sum( x );

    

Variables
---------

The previous discussion of quantified expressions illustrates the syntax needed to
declare variables and other components with quantifier notation.
Variable declarations require the specification of various information:

* Lower bound values
* Upper bound values
* Initial values
* Variable type (continuous, binary, integer, etc)

When specifying a tensor of variables, it is sometimes desirable to
specify variable parameters that depend on the indices of the variable.
For example:

.. math::

    \begin{array}{c}
    x \in R^{n \times m}\\
    0 \leq x_{ij} \leq i \cdot j\\
    x_{ij} = i + j
    \end{array}

We can decelare `x` using set indices that are used in expressions
defining the values of lower- and upper-bounds, and the initial values.
For example:

.. code:: C++

    auto M = coek::RangeSet(1,m);
    auto N = coek::RangeSet(1,n);
    auto i = set_element("i");
    auto j = set_element("j");

    auto x = model.add( coek::variable("x", Forall(i,j).In(M*N)) ).
                lower(0).
                upper(i*j).
                value(i+j);

Note that this syntax can be extended to allow for the use of mutable
parameters as well:

.. code:: C++

    auto i = set_element("i");
    auto j = set_element("j");
    auto p = parameter("p", 1.0);

    auto M = coek::RangeSet(1,m);
    auto N = coek::RangeSet(1,n);
    auto x = model.add( coek::variable("x", Forall(i,j).In(M*N)) ).
                lower(0).
                upper(i*(j+p)).
                value(i+j);

Here, the value of the upper-bound depends on `p`, which may be changed
after the variable is declared.  COEK uses the expression logic to
appropriately account for that change to the model.

.. admonition:: WEH

    Do we need the following?

    Finally, note that in these examples the order of indices in the index
    set is implicitly defined by the nesting of the calls to `Forall()`.
    However, it may be necessary to explicitly denote the order of indices.
    For example:

    .. code:: C++

        auto i = set_element("i");
        auto j = set_element("j");

        auto M = coek::RangeSet(1,m);
        std::vector<coek::ConcreteSet> N(m);
        auto x = model.add( coek::variable("x", Forall(i).In(M).Forall(j).In(N[i])).index( {j,i} ) ).
                lower(0).
                upper(i*j).
                value(i+j);


Parameters
----------

Mutable parameters indexed with quantified expressions can be declared in a similar manner:

.. code:: C++

    auto i = set_element("i");
    auto j = set_element("j");

    auto Q = coek::parameter("Q", Forall(i,j).In(A*B)).
                value(i+j);


Objectives
----------

Indexed objectives are not currently supported in COEK.

.. admonition:: WEH

    Although not often used, we could also support various ways to declare
    groups of objectives:

    .. code:: C++

        auto A = coek::RangeSet(1,10);
        auto B = coek::RangeSet(11,20);
        auto i = coek::set_element("i");
        auto j = coek::set_element("j");

        auto x = model.add( coek::variable("x", M*N) );
        auto o = model.add( coek::objective("o", Forall(i,j).In(M*N)) ).
                    expr( i*j*x(i,j) );
        auto O = model.add( coek::objective("O", Forall(i).In(M)) ).
                    expr( i*Sum(x(i,j), Forall(j).In(M))) );


Constraints
-----------

Constraints indexed with quantified expressions can be declared in a similar manner:

.. code:: C++

    auto M = coek::RangeSet(1,10);
    auto N = coek::RangeSet(11,20);
    auto i = coek::set_element("i");
    auto j = coek::set_element("j");

    auto x = model.add( coek::variable("x", M*N) );
    auto c = model.add( coek::constraint("c", Forall(i,j).In(M*N)) ).
                            expr( i*j*x(i,j) == 0 );
    auto C = model.add( coek::constraint("C", Forall(i).In(M)) ).
                            expr( i*Sum(x(i,j), Forall(j).In(M)) == 0 );


