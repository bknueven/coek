#!/usr/bin/env python
#
# Generate graphs and other summaries of the results
#

import sys
import json
import os
from os.path import join, getsize
import pprint
from tabulate import tabulate

def get_runtimes(fname):
    ans = {}
    with open(fname,'r') as INPUT:
        for line in INPUT.readlines():
            line.strip()
            tmp = line.split(' ')
            ans[tmp[0]] = float(tmp[1])
    return ans

def collect_exp(fname, exp):
    try:
        name = fname.split('.')[0]
        tmp = name.split('_')
        if exp == 'writer':
            return name, dict(suffix=tmp[0], model=tmp[1], args=tmp[2:])
        elif exp == 'solve0':
            return name, dict(solver=tmp[0], model=tmp[1], args=tmp[2:])
    except:
        raise RuntimeError("Bad experiment: "+fname)
    raise RuntimeError("Unknown experiment: "+fname)

def get_filedata(fname):
    if not os.path.exists(fname):
        return {'lines':None, 'bytes':None}
    ans = {}
    with open(fname, 'r') as INPUT:
        ans['lines'] = len(INPUT.readlines())
    ans['bytes'] = os.path.getsize(fname)
    return ans

def collect_results(directory, save=False):
    exp = os.path.basename(directory)
    results = {}
    for root, dirs, files in os.walk(directory):
        if len(dirs) > 0:
            continue
        test = os.path.basename(root)
        print("Collecting test results for "+test)
        results[test] = {}
        for fname in files:
            if fname.endswith('.log') or fname.endswith('.csv'):
                continue
            name, values = collect_exp(fname, exp)
            if name not in results[test]:
                results[test][name] = values
            else:
                results[test][name].update(values)
            if fname.endswith(".out"):
                results[test][name]['time'] = get_runtimes(join(root,fname))
                if len(results[test][name]['time']) == 0:
                    raise RuntimeError("Bad time info: "+fname)
            else:
                results[test][name]['size'] = get_filedata(join(root,fname))
        if save:
            if exp == 'writer':
                with open(os.path.join(root,"results.csv"),'w') as OUTPUT:
                    OUTPUT.write("Suffix,Model,Size,Test,Real,User,Lines,Bytes\n")
                    for name in results[test]:
                        tmp = results[test][name]
                        if 'timeout' in tmp['time']:
                            OUTPUT.write("{},{},{},{},,,,\n".format(tmp['suffix'], tmp['model'], tmp['args'][0], test))
                        else:
                            OUTPUT.write("{},{},{},{},{},{},{},{}\n".format(tmp['suffix'], tmp['model'], tmp['args'][0], test, tmp['time']['real'], tmp['time']['user'], tmp['size']['lines'], tmp['size']['bytes']))
            elif exp == 'solve0':
                with open(os.path.join(root,"results.csv"),'w') as OUTPUT:
                    OUTPUT.write("Sollver,Model,Size,Test,Real,User,Lines,Bytes\n")
                    for name in results[test]:
                        tmp = results[test][name]
                        if 'timeout' in tmp['time']:
                            OUTPUT.write("{},{},{},{},,,,\n".format(tmp['solver'], tmp['model'], tmp['args'][0], test))
                        else:
                            OUTPUT.write("{},{},{},{},{},{},{},{}\n".format(tmp['solver'], tmp['model'], tmp['args'][0], test, tmp['time']['real'], tmp['time']['user'], tmp['size']['lines'], tmp['size']['bytes']))
                
    return results


def writer_lp_times(data, largest=False):
    for problem in ['knapsack', 'pmedian', 'lqcp', 'fac', 'nqueens']:
        results = []
        for test in data:
            for k,v in data[test].items():
                if v['suffix'] != 'lp':
                    continue
                if not v['model'].startswith(problem):
                    continue
                if 'timeout' in v['time']:
                    results.append([v['model'], int(v['args'][0]), test, None, None, None, None])
                else:
                    results.append([v['model'], int(v['args'][0]), test, v['time']['real'], v['time']['user'], v['size']['lines'], v['size']['bytes']])

        if largest:
            l = max(r[1] for r in results)
            results = [r for r in results if r[1] == l]

        g_real = {}
        g_user = {}
        g_lines = {}
        g_bytes = {}
        for r in results:
            if r[2] == 'gurobi':
                g_real[r[1]] = r[3]
                g_user[r[1]] = r[4]
                g_lines[r[1]] = r[5]
                g_bytes[r[1]] = r[6]
        for r in results:
            if r[3] is None:
                r.append(r[3])
                r.append(r[4])
                r.append(r[5])
                r.append(r[6])
            elif r[1] in g_real:
                r.append(r[3]/g_real[r[1]])
                r.append(r[4]/g_user[r[1]])
                r.append(r[5]/g_lines[r[1]])
                r.append(r[6]/g_bytes[r[1]])
            else:
                r.append(None)
                r.append(None)
                r.append(None)
                r.append(None)
        print("")
        print(tabulate(sorted(results,key=lambda x:(x[0].split('-')[0],x[2],x[0],x[1])), headers=["Model", "Size", "Test", "Real", "User", "Lines", "Bytes", "RealRatio", "UserRatio", "LinesRatio", "BytesRatio"]))


if __name__ == "__main__":
    directory = 'results' if len(sys.argv) < 3 else sys.argv[2]

    if False:
        pass

    elif sys.argv[1] == "dev":
        collect_results(directory+"/writer", save=True)

    elif sys.argv[1] == "writer_lp_times":
        data = collect_results(directory+"/writer")
        writer_lp_times(data)

    elif sys.argv[1] == "writer_lp_times_largest":
        data = collect_results(directory+"/writer")
        writer_lp_times(data, largest=True)

    elif sys.argv[1] == "print_results":
        pprint.pprint(collect_results(directory+"/writer"))
        
    else:
        print("dog options")
        print("  writer_lp_times")
        print("  writer_lp_times_largest")
        print("  print_results")
